<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>WPPConnect Dashboard</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style>
      :root {
        color-scheme: light dark;
        --primary: #1c7ed6;
        --bg: #0f172a;
        --card-bg: rgba(15, 23, 42, 0.85);
        --text: #e2e8f0;
        --muted: #94a3b8;
        --success: #2fb344;
        --error: #e03131;
        --warn: #f08c00;
        font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      }

      body {
        margin: 0;
        background: radial-gradient(circle at top left, #1e293b, #020617);
        color: var(--text);
        min-height: 100vh;
      }

      header {
        padding: 1.5rem;
        background: rgba(2, 6, 23, 0.85);
        backdrop-filter: blur(12px);
        border-bottom: 1px solid rgba(148, 163, 184, 0.2);
      }

      header h1 {
        margin: 0;
        font-weight: 600;
      }

      main {
        padding: 2rem;
        display: grid;
        gap: 1.5rem;
      }

      section {
        background: var(--card-bg);
        border: 1px solid rgba(148, 163, 184, 0.2);
        border-radius: 18px;
        padding: 1.5rem;
        box-shadow: 0 20px 35px -20px rgba(15, 23, 42, 0.6);
      }

      h2 {
        margin-top: 0;
        font-size: 1.2rem;
        display: flex;
        align-items: center;
        gap: 0.5rem;
      }

      .grid {
        display: grid;
        gap: 1.5rem;
      }

      @media (min-width: 960px) {
        .grid-two {
          grid-template-columns: 1.5fr 1fr;
        }
      }

      .status-chips {
        display: flex;
        flex-wrap: wrap;
        gap: 0.5rem;
      }

      .chip {
        padding: 0.4rem 0.9rem;
        border-radius: 999px;
        background: rgba(148, 163, 184, 0.15);
        color: var(--muted);
        font-size: 0.85rem;
      }

      .chip.active {
        background: rgba(31, 179, 68, 0.15);
        color: var(--success);
      }

      .controls {
        display: flex;
        flex-wrap: wrap;
        gap: 0.75rem;
        align-items: center;
      }

      button {
        padding: 0.65rem 1.4rem;
        border-radius: 12px;
        border: none;
        background: var(--primary);
        color: #fff;
        font-size: 0.95rem;
        cursor: pointer;
        transition: transform 0.15s ease, box-shadow 0.15s ease,
          opacity 0.15s ease;
      }

      button.secondary {
        background: rgba(148, 163, 184, 0.3);
      }

      button:disabled {
        opacity: 0.65;
        cursor: not-allowed;
      }

      button:hover:not(:disabled) {
        transform: translateY(-2px);
        box-shadow: 0 12px 20px -14px rgba(28, 126, 214, 0.9);
      }

      form {
        display: grid;
        gap: 1rem;
      }

      label {
        display: grid;
        gap: 0.4rem;
        font-size: 0.9rem;
        color: var(--muted);
      }

      input,
      textarea {
        padding: 0.75rem 1rem;
        border-radius: 12px;
        border: 1px solid rgba(148, 163, 184, 0.25);
        background: rgba(15, 23, 42, 0.6);
        color: var(--text);
        font-size: 0.95rem;
        resize: vertical;
      }

      pre {
        background: rgba(15, 23, 42, 0.65);
        border-radius: 14px;
        padding: 1rem;
        font-size: 0.75rem;
        line-height: 0.9rem;
        overflow: auto;
        max-height: 360px;
        border: 1px solid rgba(148, 163, 184, 0.16);
      }

      table {
        width: 100%;
        border-collapse: collapse;
        font-size: 0.9rem;
      }

      th,
      td {
        padding: 0.6rem 0.5rem;
        border-bottom: 1px solid rgba(148, 163, 184, 0.12);
        text-align: left;
      }

      tbody tr:hover {
        background: rgba(148, 163, 184, 0.08);
      }

      .log {
        display: grid;
        gap: 0.5rem;
        font-family: 'Fira Mono', 'Courier New', Courier, monospace;
        font-size: 0.85rem;
      }

      .log-entry {
        padding: 0.65rem 0.75rem;
        border-radius: 10px;
        background: rgba(148, 163, 184, 0.08);
        border: 1px solid rgba(148, 163, 184, 0.12);
      }

      .log-entry.info {
        border-color: rgba(47, 179, 68, 0.3);
      }

      .log-entry.warn {
        border-color: rgba(240, 140, 0, 0.3);
      }

      .log-entry.error {
        border-color: rgba(224, 49, 49, 0.3);
      }

      .qr-placeholder {
        color: var(--muted);
      }

      .message {
        color: var(--muted);
        min-height: 1rem;
      }

      .toast-container {
        position: fixed;
        top: 1rem;
        right: 1rem;
        z-index: 9999;
        display: flex;
        flex-direction: column;
        gap: 0.75rem;
        max-width: 380px;
      }

      .toast {
        padding: 1rem 1.25rem;
        border-radius: 12px;
        background: rgba(15, 23, 42, 0.95);
        border: 1px solid rgba(148, 163, 184, 0.25);
        box-shadow: 0 20px 35px -20px rgba(15, 23, 42, 0.8);
        animation: slideIn 0.3s ease-out;
        display: flex;
        align-items: center;
        gap: 0.75rem;
        font-size: 0.9rem;
      }

      @keyframes slideIn {
        from {
          transform: translateX(400px);
          opacity: 0;
        }
        to {
          transform: translateX(0);
          opacity: 1;
        }
      }

      @keyframes slideOut {
        to {
          transform: translateX(400px);
          opacity: 0;
        }
      }

      .toast.closing {
        animation: slideOut 0.3s ease-out forwards;
      }

      .toast.info {
        border-color: rgba(28, 126, 214, 0.3);
      }

      .toast.success {
        border-color: rgba(31, 179, 68, 0.3);
      }

      .toast.warn {
        border-color: rgba(240, 140, 0, 0.3);
      }

      .toast.error {
        border-color: rgba(224, 49, 49, 0.3);
      }

      .toast-icon {
        font-size: 1.2rem;
        flex-shrink: 0;
      }

      .checkbox-group {
        display: flex;
        align-items: center;
        gap: 0.5rem;
        margin-bottom: 1rem;
      }

      .checkbox-group input[type='checkbox'] {
        width: 18px;
        height: 18px;
        cursor: pointer;
      }

      .checkbox-group label {
        margin: 0;
        display: flex;
        align-items: center;
        gap: 0.5rem;
        font-size: 0.9rem;
        color: var(--muted);
        cursor: pointer;
      }

      .status-badge {
        display: inline-flex;
        align-items: center;
        gap: 0.4rem;
        padding: 0.5rem 0.8rem;
        border-radius: 999px;
        font-size: 0.85rem;
        font-weight: 500;
      }

      .status-badge.idle {
        background: rgba(148, 163, 184, 0.15);
        color: var(--muted);
      }

      .status-badge.loading {
        background: rgba(240, 140, 0, 0.15);
        color: #f08c00;
        animation: pulse 1.5s ease-in-out infinite;
      }

      .status-badge.authenticating {
        background: rgba(240, 140, 0, 0.15);
        color: #f08c00;
        animation: pulse 1s ease-in-out infinite;
      }

      .status-badge.qr-pending {
        background: rgba(240, 140, 0, 0.15);
        color: #f08c00;
        animation: pulse 0.8s ease-in-out infinite;
      }

      .status-badge.logged-in {
        background: rgba(31, 179, 68, 0.15);
        color: var(--success);
      }

      .status-badge.running {
        background: rgba(31, 179, 68, 0.15);
        color: var(--success);
        animation: pulse 2s ease-in-out infinite;
      }

      .status-badge.error {
        background: rgba(224, 49, 49, 0.15);
        color: var(--error);
      }

      .status-dot {
        width: 8px;
        height: 8px;
        border-radius: 50%;
        background: currentColor;
      }

      @keyframes pulse {
        0%,
        100% {
          opacity: 1;
        }
        50% {
          opacity: 0.6;
        }
      }

      .uptime {
        font-size: 0.8rem;
        color: var(--muted);
        margin-top: 0.25rem;
      }
    </style>
  </head>
  <body>
    <div class="toast-container" id="toast-container"></div>
    <header>
      <h1>WPPConnect Dashboard</h1>
      <p id="session-name">Session: &mdash;</p>
    </header>
    <main class="grid grid-two">
      <section>
        <h2>Controls</h2>
        <div class="checkbox-group">
          <input type="checkbox" id="auto-start-checkbox" />
          <label for="auto-start-checkbox">Iniciar WPP automáticamente</label>
        </div>
        <div class="controls">
          <button id="start-btn">Start Session</button>
          <button id="stop-btn" class="secondary">Stop Session</button>
          <div id="connection-state" class="status-badge idle">
            <span class="status-dot"></span>
            <span>IDLE</span>
          </div>
        </div>
        <div class="uptime" id="uptime"></div>
        <p class="message" id="action-feedback"></p>
        <div>
          <h3>Status History</h3>
          <div class="status-chips" id="status-history"></div>
        </div>
      </section>

      <section>
        <h2>QR Code</h2>
        <pre id="qr-display" class="qr-placeholder">
Waiting for QR code...
        </pre>
      </section>

      <section>
        <h2>Send a Message</h2>
        <form id="send-message-form">
          <label>
            Recipient (e.g. 5511999999999@c.us)
            <input type="text" name="to" placeholder="Recipient JID" required />
          </label>
          <label>
            Message
            <textarea
              name="message"
              rows="4"
              placeholder="Type the message you want to send"
              required
            ></textarea>
          </label>
          <div class="controls">
            <button type="submit">Send Message</button>
            <span id="send-feedback" class="message"></span>
          </div>
        </form>
      </section>

      <section>
        <h2>Recent Messages</h2>
        <div style="overflow-x: auto">
          <table>
            <thead>
              <tr>
                <th>Timestamp</th>
                <th>From</th>
                <th>Preview</th>
              </tr>
            </thead>
            <tbody id="message-history">
              <tr>
                <td colspan="3">Waiting for data...</td>
              </tr>
            </tbody>
          </table>
        </div>
      </section>

      <section>
        <h2>Logs</h2>
        <div id="log-output" class="log"></div>
      </section>
    </main>

    <script>
      const $ = (selector) => document.querySelector(selector);
      const statusEndpoint = '/api/status';
      const STORAGE_KEY = 'wpp-dashboard-auto-start';
      const STORAGE_SESSION_START = 'wpp-session-start-time';

      let sessionStartTime = null;

      const elements = {
        sessionName: $('#session-name'),
        connectionState: $('#connection-state'),
        statusHistory: $('#status-history'),
        qrDisplay: $('#qr-display'),
        messageHistory: $('#message-history'),
        logOutput: $('#log-output'),
        startBtn: $('#start-btn'),
        stopBtn: $('#stop-btn'),
        actionFeedback: $('#action-feedback'),
        sendForm: $('#send-message-form'),
        sendFeedback: $('#send-feedback'),
        autoStartCheckbox: $('#auto-start-checkbox'),
        toastContainer: $('#toast-container'),
        uptime: $('#uptime'),
      };

      // Toast notifications
      function showToast(message, type = 'info') {
        const toast = document.createElement('div');
        toast.className = `toast ${type}`;

        const icons = {
          info: 'ℹ️',
          success: '✓',
          warn: '⚠️',
          error: '✕',
        };

        toast.innerHTML = `
          <span class="toast-icon">${icons[type] || icons.info}</span>
          <span>${escapeHtml(message)}</span>
        `;

        elements.toastContainer.appendChild(toast);

        setTimeout(() => {
          toast.classList.add('closing');
          setTimeout(() => toast.remove(), 300);
        }, 3000);
      }

      // Storage management
      function getAutoStartPreference() {
        return localStorage.getItem(STORAGE_KEY) === 'true';
      }

      function setAutoStartPreference(value) {
        localStorage.setItem(STORAGE_KEY, value ? 'true' : 'false');
        elements.autoStartCheckbox.checked = value;
      }

      function getSessionStartTime() {
        const stored = localStorage.getItem(STORAGE_SESSION_START);
        return stored ? new Date(stored) : null;
      }

      function setSessionStartTime(time) {
        if (time) {
          sessionStartTime = time;
          localStorage.setItem(STORAGE_SESSION_START, time.toISOString());
        } else {
          sessionStartTime = null;
          localStorage.removeItem(STORAGE_SESSION_START);
        }
      }

      function formatUptime(startTime) {
        if (!startTime) return '';
        const now = new Date();
        const diff = now - startTime;

        const seconds = Math.floor((diff / 1000) % 60);
        const minutes = Math.floor((diff / (1000 * 60)) % 60);
        const hours = Math.floor((diff / (1000 * 60 * 60)) % 24);
        const days = Math.floor(diff / (1000 * 60 * 60 * 24));

        if (days > 0) return `Conectado hace ${days}d ${hours}h`;
        if (hours > 0) return `Conectado hace ${hours}h ${minutes}m`;
        if (minutes > 0) return `Conectado hace ${minutes}m`;
        return `Conectado hace ${seconds}s`;
      }

      function updateStatusBadge(isRunning, connectionState) {
        const badge = elements.connectionState;
        badge.className = 'status-badge';

        const stateMap = {
          IDLE: 'idle',
          LOADING: 'loading',
          AUTHENTICATING: 'authenticating',
          QR_PENDING: 'qr-pending',
          LOGGED_IN: 'logged-in',
          RUNNING: 'running',
          ERROR: 'error',
        };

        const stateClass = stateMap[connectionState] || 'idle';
        badge.classList.add(stateClass);

        const labels = {
          idle: 'INACTIVO',
          loading: 'CARGANDO...',
          authenticating: 'AUTENTICANDO...',
          'qr-pending': 'QR PENDIENTE',
          'logged-in': 'CONECTADO',
          running: 'EN EJECUCIÓN',
          error: 'ERROR',
        };

        badge.innerHTML = `
          <span class="status-dot"></span>
          <span>${labels[stateClass]}</span>
        `;
      }

      async function fetchStatus() {
        try {
          const response = await fetch(statusEndpoint, {
            cache: 'no-store',
          });
          if (!response.ok) {
            throw new Error(`Request failed: ${response.status}`);
          }

          const data = await response.json();
          updateDashboard(data);
        } catch (error) {
          console.error(error);
          elements.actionFeedback.textContent =
            'No se puede alcanzar el API del dashboard. Verifica el backend.';
          updateStatusBadge(false, 'ERROR');
        }
      }

      function updateDashboard(data) {
        elements.sessionName.textContent = `Session: ${data.session}`;

        const connectionState =
          data.connectionState || (data.running ? 'RUNNING' : 'IDLE');
        updateStatusBadge(data.running, connectionState);

        // Handle session start time
        if (data.running && !sessionStartTime) {
          setSessionStartTime(new Date());
          showToast('WPP conectado exitosamente', 'success');
        } else if (!data.running && sessionStartTime) {
          setSessionStartTime(null);
          showToast('WPP desconectado', 'warn');
        }

        // Update uptime display
        if (sessionStartTime) {
          elements.uptime.textContent = formatUptime(sessionStartTime);
        } else {
          elements.uptime.textContent = '';
        }

        if (data.qr && data.qr.ascii) {
          elements.qrDisplay.textContent = data.qr.ascii;
          elements.qrDisplay.classList.remove('qr-placeholder');
        } else {
          elements.qrDisplay.textContent = 'Esperando código QR...';
          elements.qrDisplay.classList.add('qr-placeholder');
        }

        renderStatusHistory(data.statusHistory || []);
        renderMessageHistory(data.messageHistory || []);
        renderLogs(data.logs || []);

        elements.startBtn.disabled = data.isStarting || data.running;
        elements.stopBtn.disabled = data.isStopping || !data.running;
      }

      function renderStatusHistory(statusHistory) {
        elements.statusHistory.innerHTML = '';

        if (!statusHistory.length) {
          const chip = document.createElement('span');
          chip.className = 'chip';
          chip.textContent = 'Sin estado aún';
          elements.statusHistory.appendChild(chip);
          return;
        }

        statusHistory
          .slice()
          .reverse()
          .forEach((entry) => {
            const chip = document.createElement('span');
            chip.className = 'chip';
            chip.textContent = `${entry.status} • ${formatTime(
              entry.timestamp
            )}`;
            elements.statusHistory.appendChild(chip);
          });
      }

      function renderMessageHistory(messages) {
        if (!messages.length) {
          elements.messageHistory.innerHTML =
            '<tr><td colspan="3">No hay mensajes aún.</td></tr>';
          return;
        }

        const rows = messages
          .slice()
          .reverse()
          .map(
            (message) => `
              <tr>
                <td>${formatTime(message.timestamp)}</td>
                <td>${escapeHtml(message.from)}</td>
                <td>${escapeHtml(message.body || '<sin contenido>')}</td>
              </tr>
            `
          )
          .join('');

        elements.messageHistory.innerHTML = rows;
      }

      function renderLogs(logs) {
        if (!logs.length) {
          elements.logOutput.innerHTML =
            '<div class="log-entry">Sin logs aún.</div>';
          return;
        }

        elements.logOutput.innerHTML = logs
          .slice()
          .reverse()
          .map(
            (log) => `
              <div class="log-entry ${log.level}">
                <strong>[${log.level.toUpperCase()}]</strong>
                ${formatTime(log.timestamp)} — ${escapeHtml(log.message)}
              </div>
            `
          )
          .join('');
      }

      function formatTime(value) {
        if (!value) return '';
        try {
          return new Intl.DateTimeFormat(undefined, {
            hour: '2-digit',
            minute: '2-digit',
            second: '2-digit',
          }).format(new Date(value));
        } catch (error) {
          return value;
        }
      }

      function escapeHtml(value) {
        return String(value ?? '')
          .replace(/&/g, '&amp;')
          .replace(/</g, '&lt;')
          .replace(/>/g, '&gt;')
          .replace(/"/g, '&quot;')
          .replace(/'/g, '&#039;');
      }

      async function callAction(endpoint, feedbackEl) {
        feedbackEl.textContent = '';
        try {
          const response = await fetch(endpoint, { method: 'POST' });
          const payload = await response.json().catch(() => ({}));

          if (!response.ok || payload.ok === false) {
            const message = payload.error || 'Acción fallida.';
            feedbackEl.textContent = message;
            showToast(message, 'error');
            fetchStatus();
            return;
          }

          feedbackEl.textContent = 'Acción completada.';
          showToast('Acción completada', 'success');
        } catch (error) {
          feedbackEl.textContent = 'Error en la solicitud. Ver consola.';
          showToast('Error en la solicitud', 'error');
          console.error(error);
        } finally {
          fetchStatus();
        }
      }

      // Event listeners
      elements.startBtn.addEventListener('click', () => {
        callAction('/api/start', elements.actionFeedback);
      });

      elements.stopBtn.addEventListener('click', () => {
        callAction('/api/stop', elements.actionFeedback);
      });

      elements.autoStartCheckbox.addEventListener('change', (e) => {
        setAutoStartPreference(e.target.checked);
        showToast(
          e.target.checked
            ? 'Auto-start habilitado'
            : 'Auto-start deshabilitado',
          'info'
        );
      });

      elements.sendForm.addEventListener('submit', async (event) => {
        event.preventDefault();
        const formData = new FormData(elements.sendForm);
        const payload = {
          to: String(formData.get('to') || '').trim(),
          message: String(formData.get('message') || '').trim(),
        };

        if (!payload.to || !payload.message) {
          elements.sendFeedback.textContent =
            'Por favor completa todos los campos.';
          showToast('Por favor completa todos los campos', 'warn');
          return;
        }

        elements.sendFeedback.textContent = 'Enviando...';

        try {
          const response = await fetch('/api/send-message', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify(payload),
          });

          const data = await response.json().catch(() => ({}));

          if (!response.ok || data.ok === false) {
            const message = data.error || 'Error al enviar mensaje.';
            elements.sendFeedback.textContent = message;
            showToast(message, 'error');
            fetchStatus();
            return;
          }

          elements.sendFeedback.textContent = 'Mensaje enviado.';
          showToast('Mensaje enviado', 'success');
          elements.sendForm.reset();
          fetchStatus();
        } catch (error) {
          console.error(error);
          elements.sendFeedback.textContent = 'Error en la solicitud.';
          showToast('Error en la solicitud', 'error');
        }
      });

      // Initialize
      function initialize() {
        // Restore auto-start preference
        const autoStartEnabled = getAutoStartPreference();
        elements.autoStartCheckbox.checked = autoStartEnabled;

        // Restore session start time if it was saved
        sessionStartTime = getSessionStartTime();

        // Initial fetch
        fetchStatus();

        // Auto-start if enabled
        if (autoStartEnabled) {
          setTimeout(() => {
            callAction('/api/start', elements.actionFeedback);
          }, 500);
        }

        // Poll every 4 seconds
        setInterval(fetchStatus, 4000);

        // Update uptime every second
        setInterval(() => {
          if (sessionStartTime) {
            elements.uptime.textContent = formatUptime(sessionStartTime);
          }
        }, 1000);
      }

      initialize();
    </script>
  </body>
</html>
